<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instagram Follower Monitor</title>
    <link rel="manifest" href="/static/manifest.json">
    <style>
        :root {
            --primary-color: #0095f6;
            --secondary-color: #00376b;
            --background-color: #fafafa;
            --card-background: #ffffff;
            --text-color: #262626;
            --border-color: #dbdbdb;
            --success-color: #00c853;
            --error-color: #ff1744;
            --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --border-radius: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 12px;
            box-sizing: border-box;
        }

        .card {
            background: var(--card-background);
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            padding: 16px;
            margin-bottom: 24px;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 16px;
            background: var(--card-background);
            padding: 16px;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
        }

        h1 {
            color: var(--secondary-color);
            font-size: 20px;
            margin: 0;
            padding: 8px 0;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        .settings {
            margin: 20px 0;
        }

        .input-group {
            margin: 16px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="number"] {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 120px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            text-align: center;
            margin: 16px 0;
            padding: 8px;
        }

        .stat-item {
            padding: 16px;
            border-radius: 8px;
            background: var(--background-color);
            transition: transform 0.2s;
        }

        .stat-item:active {
            transform: scale(0.98);
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 14px;
            color: var(--secondary-color);
            margin-top: 4px;
        }

        .graph-container {
            margin: 16px 0;
            padding: 16px;
            background: var(--card-background);
            border-radius: 8px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .graph {
            font-family: monospace;
            white-space: pre;
            font-size: 10px;
            line-height: 1.2;
            overflow-x: scroll;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 16px;
        }

        .history-container {
            margin-top: 16px;
        }

        .history-item {
            padding: 12px 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-time {
            color: var(--secondary-color);
            font-size: 14px;
        }

        .history-date {
            font-weight: bold;
            color: var(--secondary-color);
            font-size: 14px;
        }

        .history-stats {
            font-size: 14px;
            color: var(--text-color);
            margin-top: 4px;
            line-height: 1.4;
        }

        .history-change {
            font-weight: bold;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .history-change.positive {
            color: var(--success-color);
            background: rgba(0, 200, 83, 0.1);
        }

        .history-change.negative {
            color: var(--error-color);
            background: rgba(255, 23, 68, 0.1);
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--secondary-color);
        }

        .empty-state p {
            margin: 10px 0;
            font-size: 14px;
        }

        .loading {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @media (max-width: 600px) {
            .container {
                padding: 8px;
            }

            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
                padding: 4px;
            }

            .stat-item {
                padding: 12px 8px;
            }

            .stat-value {
                font-size: 18px;
            }

            .stat-label {
                font-size: 12px;
            }

            .history-item {
                padding: 12px 8px;
            }

            .history-stats {
                width: 100%;
                margin-top: 8px;
            }

            .card {
                padding: 12px;
                margin-bottom: 16px;
            }

            h2 {
                font-size: 18px;
                margin: 8px 0;
            }
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            :root {
                --background-color: #121212;
                --card-background: #1e1e1e;
                --text-color: #ffffff;
                --border-color: #2d2d2d;
                --secondary-color: #89b4e8;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Instagram Follower Monitor</h1>
            <button id="installButton" style="display: none;">Install App</button>
        </div>

        <div class="card" id="stats"></div>

        <div class="card graph-container">
            <h2>Follower History</h2>
            <div id="graph" class="graph"></div>
        </div>

        <div class="card history-container">
            <h2>Recent Updates</h2>
            <div id="history"></div>
        </div>
    </div>

    <script>
        const INSTAGRAM_USER_ID = "51651500950";
        let deferredPrompt;
        let followerHistory = [];
        const MAX_HISTORY = 2016; // 7 days of 5-minute intervals
        let lastUpdate = 0;
        const UPDATE_INTERVAL = 300000; // 5 minutes in milliseconds
        let updateInterval = null;
        let countdownInterval = null;

        // Handle PWA installation
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installButton').style.display = 'inline-block';
        });

        // Install button click handler
        document.getElementById('installButton').addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') {
                    document.getElementById('installButton').style.display = 'none';
                }
                deferredPrompt = null;
            }
        });

        // Format date for display
        function formatDate(date) {
            let nowStr = new Date().toLocaleString('en-US', { timeZone: 'Asia/Kolkata' });
            let dateStr = new Date(date).toLocaleString('en-US', { timeZone: 'Asia/Kolkata' });
            let now = new Date(nowStr);
            let d = new Date(dateStr);

            if (d.toDateString() === now.toDateString()) {
                return d.toLocaleTimeString('en-US', { 
                    timeZone: 'Asia/Kolkata',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                });
            }
            return d.toLocaleDateString('en-US', { timeZone: 'Asia/Kolkata' }) + ' ' + 
                   d.toLocaleTimeString('en-US', { 
                       timeZone: 'Asia/Kolkata',
                       hour: '2-digit',
                       minute: '2-digit',
                       hour12: true
                   });
        }

        // Load history from server
        async function fetchData() {
            try {
                // Only fetch if enough time has passed
                const now = Date.now();
                if (now - lastUpdate < UPDATE_INTERVAL && followerHistory.length > 0) {
                    return;
                }
                
                const response = await fetch(`/amishi/api/data/${INSTAGRAM_USER_ID}/`);
                const data = await response.json();
                
                if (data.stats && data.history) {
                    followerHistory = data.history;
                    updateUI(data.stats);
                    lastUpdate = now;
                    // Update UI immediately after loading history
                    updateGraph();
                    updateHistory();
                    updateCountdown();
                } else {
                    throw new Error('Failed to fetch Instagram data');
                }
            } catch (error) {
                console.error('Error loading history:', error);
                showError(error);
                throw error;  // Propagate error for better handling
            }
        }

        function showError(error) {
            document.getElementById('stats').innerHTML = `
                <div class="empty-state">
                    <h3>Error Loading Data</h3>
                    <p>${error.message}</p>
                    <p>Retrying in a few seconds...</p>
                </div>
            `;
        }

        function updateUI(stats) {
            document.getElementById('stats').innerHTML = `
                <h2 style="text-align: center;">${stats.username}</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value">${stats.follower_count.toLocaleString()}</div>
                        <div class="stat-label">Followers</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.following_count.toLocaleString()}</div>
                        <div class="stat-label">Following</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.media_count.toLocaleString()}</div>
                        <div class="stat-label">Posts</div>
                    </div>
                </div>
                <p style="white-space: pre-wrap; text-align: center;">${stats.biography || ''}</p>
                ${stats.external_url ? `<p style="text-align: center;"><a href="${stats.external_url}" target="_blank">${stats.external_url}</a></p>` : ''}
                <p style="text-align: center; color: var(--secondary-color);">Last Updated: ${new Date(stats.last_updated).toLocaleString('en-US', { 
                    timeZone: 'Asia/Kolkata',
                    dateStyle: 'medium',
                    timeStyle: 'medium'
                })}</p>
            `;
        }

        async function startMonitoring() {
            try {
                const response = await fetch('/amishi/api/start_monitoring/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        user_id: INSTAGRAM_USER_ID
                    })
                });
                const result = await response.json();
                if (result.status === 'success' && result.stats) {
                    // Use initial stats from monitoring response
                    updateUI(result.stats);
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error:', error);
                throw error;
            }
        }

        // Initialize the page
        async function init() {
            // Clear any existing intervals
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            // Show loading state
            document.getElementById('stats').innerHTML = `
                <div class="empty-state">
                    <h3>Loading...</h3>
                    <p>Fetching Instagram data...</p>
                </div>
            `;
            
            try {
                // Start monitoring first
                const monitoringStarted = await startMonitoring();
                
                if (!monitoringStarted) {
                    throw new Error('Failed to start monitoring');
                }
                
                // Then fetch full data including history
                await fetchData();
                
                // Start the update interval
                updateInterval = setInterval(fetchData, UPDATE_INTERVAL);
            } catch (error) {
                console.error('Error during initialization:', error);
                showError(error);
                // Retry after 5 seconds
                setTimeout(init, 5000);
            }
        }

        function updateGraph() {
            const graphElement = document.getElementById('graph');
            // Limit the number of points to prevent performance issues
            const maxPoints = 288; // 24 hours worth of 5-minute intervals
            const displayHistory = followerHistory.slice(-maxPoints);

            if (displayHistory.length < 2) {
                graphElement.innerHTML = `
                    <div class="empty-state">
                        <h3>Collecting Data...</h3>
                        <p>The graph will appear after collecting at least 2 data points.</p>
                        <p>Next update in: <span id="nextUpdate" class="loading">5:00</span></p>
                    </div>
                `;
                return;
            }

            const values = displayHistory.map(h => h.count);
            const max = Math.max(...values);
            const min = Math.min(...values);
            const range = max - min || 1; // Prevent division by zero
            const height = 15; // Increased height for better visibility
            let graph = '  Follower Count Over Time\n\n';

            // Create y-axis labels
            for (let i = height - 1; i >= 0; i--) {
                const value = min + (range * (i / (height - 1)));
                graph += value.toFixed(0).padStart(8) + ' │';
                
                // Add data points
                for (let j = 0; j < values.length; j++) {
                    const normalizedValue = (values[j] - min) / range;
                    const position = Math.round(normalizedValue * (height - 1));
                    // Use different characters for different times of day
                    if (position === i) {
                        const hour = new Date(followerHistory[j].timestamp).getHours();
                        graph += hour >= 6 && hour < 18 ? '●' : '○';
                    } else {
                        graph += ' ';
                    }
                }
                graph += '\n';
            }

            // Add x-axis
            graph += '         └' + '─'.repeat(values.length) + '\n';
            
            // Add time labels more sparsely
            const timeLabels = [];
            const interval = Math.floor(values.length / 6); // Show 6 time points
            for (let i = 0; i < values.length; i += interval) {
                timeLabels.push(formatDate(followerHistory[i].timestamp));
            }
            timeLabels.push(formatDate(followerHistory[values.length - 1].timestamp));
            
            graph += '         ' + timeLabels.join('  ');

            graphElement.textContent = graph;
        }

        function updateHistory() {
            const historyElement = document.getElementById('history');
            if (followerHistory.length === 0) {
                historyElement.innerHTML = `
                    <div class="empty-state">
                        <h3>No History Yet</h3>
                        <p>Historical data will appear here as it's collected.</p>
                        <p>Data is collected every 5 minutes.</p>
                    </div>
                `;
                return;
            }

            // Group by date
            const groupedHistory = {};
            followerHistory.forEach(item => {
                const date = new Date(item.timestamp).toDateString();
                if (!groupedHistory[date]) {
                    groupedHistory[date] = {
                        date: date,
                        start: item.count,
                        end: item.count,
                        min: item.count,
                        max: item.count
                    };
                } else {
                    groupedHistory[date].end = item.count;
                    groupedHistory[date].min = Math.min(groupedHistory[date].min, item.count);
                    groupedHistory[date].max = Math.max(groupedHistory[date].max, item.count);
                }
            });

            const historyHtml = Object.values(groupedHistory).reverse().map(day => `
                <div class="history-item">
                    <div>
                        <div class="history-date">${day.date}</div>
                        <div class="history-stats">
                            Start: ${day.start.toLocaleString()} → End: ${day.end.toLocaleString()}
                            <br>
                            Min: ${day.min.toLocaleString()} | Max: ${day.max.toLocaleString()}
                        </div>
                    </div>
                    <div class="history-change ${day.end > day.start ? 'positive' : day.end < day.start ? 'negative' : ''}">
                        ${day.end - day.start > 0 ? '+' : ''}${(day.end - day.start).toLocaleString()}
                    </div>
                </div>
            `).join('');
            historyElement.innerHTML = historyHtml;
        }

        // Update countdown timer
        function updateCountdown() {
            // Clear existing countdown
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            let timeLeft = 300; // 5 minutes in seconds
            
            countdownInterval = setInterval(() => {
                const nextUpdate = document.getElementById('nextUpdate');
                if (!nextUpdate) {
                    clearInterval(countdownInterval);
                    return;
                }

                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                nextUpdate.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft === 0) {
                    timeLeft = 300;
                    fetchData();  // Fetch new data when countdown reaches zero
                } else {
                    timeLeft--;
                }
            }, 1000);
        }

        // Initialize when page loads and add error handling
        window.addEventListener('load', () => {
            init().catch(error => {
                console.error('Error during initialization:', error);
                showError(error);
            });
        });

        // Clean up when page unloads
        window.addEventListener('unload', () => {
            if (updateInterval) clearInterval(updateInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        });
    </script>
</body>
</html> 